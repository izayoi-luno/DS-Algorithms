# leetcode
1. #70 爬楼梯 (int n)
    - 直接递归O(2^n)
    - 自顶向下 递归+哈希表O(n)
    - 自底向上 迭代 保存pre和prePre 动态规划
## Array/配列/数组
2. #1 两数之和 (vector<int>& nums, int target) 
    - 双指针O(n^2)
    - one pass 哈希表O(n)
3. #88 合并两个有序数组(vector<int>& nums1, int m, vector<int>& nums2, int n)
    - 双指针（三）+临时数组O(m+n)
    - 双指针（三）+从尾部比较O(m+n)
4. #283 移动零(vector<int>& nums)
    - 双指针O(n)
5. #448 消失的数字(vector<int>& nums)
    - 哈希表 时O(n)+空O(n)
    - 利用数组下标范围和值的范围的关系 修改数组的值
## Linked list/連結リスト/链表
6. #21 合并两个有序链表(ListNode* list1, ListNode* list2)
    - 双指针O(m+n)+O(1)
    - 递归O(m+n)+O(m+n)
7. #83 删除排序链表中的重复元素(ListNode* head)
    - 指针遍历O(n)+O(1)
    - 递归O(n)+O(n)
8. #141 环形链表(ListNode* head)
    - 哈希表O(n)+O(n)
    - 弗洛伊德法-快慢双指针--->环上的差速运动/追及问题 肯定会相遇O(n)+O(1)
9. #142 环形链表II(ListNode* head)
    - 哈希表O(n)+O(n)
    - 快慢双指针+找到有环后双指针同速(数学问题--->差值固定 并且与相遇位置相关)O(n)+O(1)
10. #180 相交链表(ListNode* headA, ListNode* headB)
    - 哈希表O(m+n)+O(m)
    - 双指针（追及问题--->追击的差值就是链表长度的差值）O(m+n)+O(1)
    - 双指针--->直接移动长度差O(m+n)+O(1)
11. #206 反转链表--->数据结构(ListNode* head)
    - 迭代-三指针O(n)+O(1)
    - 递归？
12. #234 回文链表(ListNode* head)
    - 双指针+复制链表到数组
    - 快慢双指针+反转链表
13. #876 链表中间结点(ListNode* head)
    - 直接遍历
    - 快慢双指针
## Stack and Queue/スタックとキュー/栈与队列
14. #232 用栈实现队列
    - 栈底作为队尾 需要额外的辅助栈来暂存 栈顶作为队首 操作方式一样
    - 输入输出栈
15. #394 解码字符串
    - 元组：数字[字符串] ---> 先进后出：栈 ---> 压栈直到读取到右括号 出栈至左括号前一位 ---> 生成字符串并继续压栈 --->继续读取源字符串 ---> 重复以上过程 （两个中括号中间的字符串拼凑成临时字符串并根据数字决定重复的次数）
## Tree/木/树
16. #94 BT中序遍历
    - LDR 2种递归
17. #144 BT前序遍历
    - DLR 2种递归
18. #145 BT 后序遍历
    - LRD 2种递归
19. #101 对称二叉树
    - 递归--->先检查左右节点是否对称--->再递归检查左子树的左节点和右子树的右节点是否对称&&左子树的右节点和右子树的左节点是否对称
    - 广搜BFS--->使用队列--->按照 左子树左节点：右子树右节点：左子树右节点：右子树左节点 的顺序依次入队并出队队首两个元素检查
20. #104 二叉树最大深度
    - 递归调用自身函数（分别传入左右节点）比较，选择最大值加一
21. #110 判断二叉树是否平衡
    - 递归--->判断二叉树子树也是平衡的
22. #226 翻转二叉树
    - 递归--->从最小单元交换
## Sorting/ソート/排序
23. #912 数组升序排序
    - 十大排序算法
## Search/検索/搜索
24. #704 二分查找
    - 递归或迭代
## BitCalculation/ビット計算/位运算
25. #136 只出现一次的数字
    - 哈希表
    - 按位异或
26. #338 比特位计数
27. #461 汉明距离
## String/文字列/字符串
28. #20 有效的括号
29. #415 字符串相加
## DynamicProgramming/動的計画法/动态规划
30. #509 斐波那契数列
    - 自底向上动态规划
31. #53 最大子序和
32. #121 买卖股票的最佳时机
    - 2D动态规划
## 其他
33. #470 用rand7()实现rand10()